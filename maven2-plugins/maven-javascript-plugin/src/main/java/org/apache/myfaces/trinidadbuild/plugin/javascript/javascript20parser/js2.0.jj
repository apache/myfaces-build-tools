/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\js2.0.jj */
/*@egen*/options {
    STATIC=false;                                                                
    DEBUG_TOKEN_MANAGER=false;
    DEBUG_PARSER=false;
}

PARSER_BEGIN(JSParser20)
package org.apache.myfaces.trinidadbuild.plugin.javascript.javascript20parser;
import java.io.IOException;
public class JSParser20/*@bgen(jjtree)*/implements JSParser20TreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected JJTJSParser20State jjtree = new JJTJSParser20State();

/*@egen*/
    //
    // This is the root node for the parse tree (root DOM node, tree of SimpleNode(s))
    //
    protected ASTProgram _jjtRoot;
    
    public ASTProgram getRootNode()
    {
    	return _jjtRoot;
    }
    
}

PARSER_END(JSParser20)



/////////////////////////////////////////////////////
// LEXICAL RULES Section
/////////////////////////////////////////////////////
TOKEN_MGR_DECLS :
{
    private boolean isRegValid = true;
    public void setRegInvalid()
    {
        isRegValid = false;
    }
    public void setRegValid()
    {
        isRegValid = true;
    }
}

/////////////////////////////////////////////////////
// WHITE SPACE 
/////////////////////////////////////////////////////
SPECIAL_TOKEN :
{
        <EOL:   (["\n","\r"])+ >
    |   <WS:    ([" ","\t"])+ >
}
/////////////////////////////////////////////////////
// COMMENTS 
/////////////////////////////////////////////////////
MORE :
{
        "//" : IN_SINGLE_LINE_COMMENT
    |   "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
        < SINGLE_LINE_COMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >  : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
        <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT, IN_MULTI_LINE_COMMENT>
MORE :
{
        < ~[] >
}
/////////////////////////////////////////////////////
// RESERVED WORDS AND LITERALS
/////////////////////////////////////////////////////
TOKEN :
{
        < AS:           "as"         >
    |   < BREAK:        "break"      >
    |   < CASE:         "case"       >
    |   < CATCH:        "catch"      >
    |   < CLASS:        "class"      >
    |   < CONST:        "const"      >
    |   < CONTINUE:     "continue"   >
    |   < _DEFAULT:     "default"    >
    |   < DELETE:       "delete"     >
    |   < DO:           "do"         >
    |   < ELSE:         "else"       >
    |   < EXTENDS:      "extends"    >
    |   < FALSE:        "false"      >   
    |   < FINALLY:      "finally"    >
    |   < FOR:          "for"        >
    |   < FUNCTION:     "function"   >
    |   < FUNCTION_:    "Function"   >
    |   < GET:          "get"        >
    |   < IF:           "if"         >
    |   < IN:           "in"         >
    |   < INCLUDE:      "include"    >
    |   < INSTANCEOF:   "instanceof" >
    |   < IS:           "is"         >
    |   < NAMESPACE:    "namespace"  >
    |   < NEW:          "new"        >
    |   < NULL:         "null"       >    
    |   < PACKAGE:      "package"    > 
    |   < PRIVATE:      "private"    >
    |   < PUBLIC:       "public"     >
    |   < RETURN:       "return"     >
    |   < SET:          "set"        >
    |   < SUPER:        "super"      >
    |   < SWITCH:       "switch"     >
    |   < THIS:         "this"       >
    |   < THROW:        "throw"      >
    |   < TRUE:         "true"       > 
    |   < TRY:          "try"        >
    |   < TYPEOF:       "typeof"     >
    |   < USE:          "use"        >
    |   < VAR:          "var"        >
    |   < VOID:         "void"       >
    |   < WHILE:        "while"      >
    |   < WITH:         "with"       >
}
/////////////////////////////////////////////////////
// FUTURE RESERVED WORDS
/////////////////////////////////////////////////////
TOKEN :
{
        < ABSTRACT:     "abstract"     >
    |   < DEBUGGER:     "debugger"     >
    |   < ENUM:         "enum"         >
    |   < EXPORT:       "export"       >
    |   < GOTO:         "goto"         >
    |   < IMPLEMENTS:   "implements"   >
    |   < INTERFACE:    "interface"    >
    |   < NATIVE:       "native"       >
    |   < PROTECTED:    "protected"    >
    |   < SYNCHRONIZED: "synchronized" >
    |   < THROWS:       "throws"       >
    |   < TRANSIENT:    "transient"    >
    |   < VOLATILE:     "volatile"     >
    |   < IMPORT:       "import"       >
}
/////////////////////////////////////////////////////
// LITERALS 
/////////////////////////////////////////////////////
TOKEN :
{
        < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
    |   < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
    |   < OCTAL_LITERAL: "0" (["0"-"7"])* >
    |   < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? 
                                |   "." (["0"-"9"])+ (<EXPONENT>)? 
                                |   (["0"-"9"])+ (<EXPONENT>)? 
        >
    |   < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
    |   < STRING_LITERAL:   "\""  
                            ( (~["\"","\\","\n","\r"]) | <ESCAPE_SEQUENCE> )* 
                            "\""
                        |   "\"" 
                            ( (~["\"","\\"]) | "\\" ("\n" | "\r" | "\r\n") | <ESCAPE_SEQUENCE> )* 
                            "\""  
                        |   "'"
                            ( (~["'","\\","\n","\r"]) | <ESCAPE_SEQUENCE> )*
                            "'"
        >
    |   < #ESCAPE_SEQUENCE: 
            "\\"
            (       ["n","t","b","r","f","\\","'","\"","[","]"]
                |   ["0"-"7"] ( ["0"-"7"] )?
                |   ["0"-"3"] ["0"-"7"] ["0"-"7"]
                |   ["x"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
                |   ["u"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"] 
                          ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
            )
        >
    |   < UNTERMINATED_STRING_LITERAL:
                "\"" ( (~["\"","\\","\n","\r"]) | <ESCAPE_SEQUENCE> )* ( ["\n","\r"] )?
            |   "'"  ( (~["'","\\","\n","\r"])  | <ESCAPE_SEQUENCE> )* ( ["\n","\r"] )?
        >
}
/////////////////////////////////////////////////////
// REGULAR EXPRESSIONS 
/////////////////////////////////////////////////////
TOKEN :
{ 
        < #REGX_START_CHAR : ~["\r","\n","/","=","*"] | "\\/">
    |   < #REGX_BODY_CHAR_EXCLUSION : ~["\r","\n","/"] >  
    |   < #REGX_BODY_CHAR : ( <REGX_BODY_CHAR_EXCLUSION> | "\\/" ) >
    |   < #REGEX_END_CHAR :     "i" 
                            |   "g" 
                            |   "m" 
                            |   "ig" 
                            |   "im" 
                            |   "gi" 
                            |   "gm" 
                            |   "mi" 
                            |   "mg" 
                            |   "igm" 
                            |   "img" 
                            |   "gmi" 
                            |   "gim" 
                            |   "mig" 
                            |   "mgi" 
                            
        >
}

TOKEN :
{
        <REGULAR_EXPRESSION : "/" <REGX_START_CHAR> (<REGX_BODY_CHAR>)* "/"  (<REGEX_END_CHAR>)? >
        {
           try {
                // Peek at the next character.
                char nextCh = input_stream.readChar();
                input_stream.backup(1);
                if (isRegValid == false || nextCh == '/' || nextCh == '*') {
                    //
                    // Lexecal analyser thinks it is a RE
                    // operator such as /...../
                    // Put the everything to the first "/" back on the input stream
                    //
                    input_stream.backup(lengthOfMatch-1);
                    //
                    // And remove it from the token
                    //
                    matchedToken.image = matchedToken.image.substring(0, 1);
                    image.delete(0, image.length() - 1);
                    image.append('/');
                    matchedToken.kind=SLASH;
                }
               } catch (IOException e) {
                    throw new Error(e.toString());
               }
       }        
        
}
/////////////////////////////////////////////////////
// IDENTIFIERS 
/////////////////////////////////////////////////////
TOKEN :
{
        < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
    |   < #LETTER: ["a"-"z","A"-"Z","$","_"] >
    |   < #DIGIT: ["0"-"9"]>
}
/////////////////////////////////////////////////////
// SEPARATORS 
/////////////////////////////////////////////////////
TOKEN :
{
        < LPAREN:    "("   >
    |   < RPAREN:    ")"   >
    |   < LBRACE:    "{"   >
    |   < RBRACE:    "}"   >
    |   < LBRACKET:  "["   >
    |   < RBRACKET:  "]"   >
    |   < SEMICOLON: ";"   >
    |   < COMMA:     ","   >
    |   < DOT:       "."   >
    |   < QUALIFIER: "::"  >
    |   < ELIPSE:    "..." >
}

/////////////////////////////////////////////////////
// OPERATORS 
/////////////////////////////////////////////////////
TOKEN :
{
        < ASSIGN:               "="    >
    |   < GT:                   ">"    >
    |   < LT:                   "<"    >
    |   < BANG:                 "!"    >
    |   < TILDE:                "~"    >
    |   < HOOK:                 "?"    >
    |   < COLON:                ":"    >
    |   < EQ:                   "=="   >
    |   < LE:                   "<="   >
    |   < GE:                   ">="   >
    |   < NE:                   "!="   >
    |   < SC_OR:                "||"   >
    |   < SC_AND:               "&&"   >
    |   < SC_XOR:               "^^"   >
    |   < INCR:                 "++"   >
    |   < DECR:                 "--"   >
    |   < PLUS:                 "+"    >
    |   < MINUS:                "-"    >
    |   < STAR:                 "*"    >
    |   < SLASH:                "/"    >
    |   < BIT_AND:              "&"    >
    |   < BIT_OR:               "|"    >
    |   < XOR:                  "^"    >
    |   < REM:                  "%"    >
    |   < LSHIFT:               "<<"   >
    |   < RSIGNEDSHIFT:         ">>"   >
    |   < RUNSIGNEDSHIFT:       ">>>"  >
    |   < PLUSASSIGN:           "+="   >
    |   < MINUSASSIGN:          "-="   >
    |   < STARASSIGN:           "*="   >
    |   < SLASHASSIGN:          "/="   >
    |   < ANDASSIGN:            "&="   >
    |   < ORASSIGN:             "|="   >
    |   < XORASSIGN:            "^="   >
    |   < REMASSIGN:            "%="   >
    |   < LSHIFTASSIGN:         "<<="  >
    |   < RSIGNEDSHIFTASSIGN:   ">>="  >
    |   < RUNSIGNEDSHIFTASSIGN: ">>>=" >
    |   < SC_ORASSIGN:          "||="  >
    |   < SC_ANDASSIGN:         "&&="  >
    |   < SC_XORASSIGN:         "^^="  >
    |   < IDENTITYOPER:         "==="  >
    |   < NOTIDENTITYOPER:      "!=="  >
}
///////////////////////////////////////////////////////////////////
// GRAMMAR Section
///////////////////////////////////////////////////////////////////

Token Program():
{/*@bgen(jjtree) Program */
        ASTProgram jjtn000 = new ASTProgram(this, JJTPROGRAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
        Token retval = getToken(1);
}
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
        (PackageDefinition())* [Directives()] <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        {
            _jjtRoot = jjtn000;
            return retval;
        }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Expressions 
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Identifier 
/////////////////////////////////////////////////////
void Identifier():
{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
        <IDENTIFIER>
    |   <GET>
    |   <SET>
    |   <INCLUDE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
//    |   <NAMESPACE>
}

/////////////////////////////////////////////////////
// Qualified Identifier 
/////////////////////////////////////////////////////
void SimpleQualifiedIdentifier():
{/*@bgen(jjtree) SimpleQualifiedIdentifier */
  ASTSimpleQualifiedIdentifier jjtn000 = new ASTSimpleQualifiedIdentifier(this, JJTSIMPLEQUALIFIEDIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleQualifiedIdentifier */
       try {
/*@egen*/
       Identifier() [<QUALIFIER> Identifier()]
    |  ReservedNamespace() [<QUALIFIER> Identifier()]/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/ 
}

void ExpressionQualifiedIdentifier():
{/*@bgen(jjtree) ExpressionQualifiedIdentifier */
  ASTExpressionQualifiedIdentifier jjtn000 = new ASTExpressionQualifiedIdentifier(this, JJTEXPRESSIONQUALIFIEDIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionQualifiedIdentifier */
       try {
/*@egen*/
       <LPAREN> AssignmentExpression() <RPAREN> <QUALIFIER> Identifier()/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/
}

void QualifiedIdentifier():
{/*@bgen(jjtree) QualifiedIdentifier */
  ASTQualifiedIdentifier jjtn000 = new ASTQualifiedIdentifier(this, JJTQUALIFIEDIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) QualifiedIdentifier */
       try {
/*@egen*/
       SimpleQualifiedIdentifier()
    |  ExpressionQualifiedIdentifier()/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/
}

/////////////////////////////////////////////////////
// Primary Expressions
/////////////////////////////////////////////////////
void PrimaryExpression ():
{/*@bgen(jjtree) PrimaryExpression */
  ASTPrimaryExpression jjtn000 = new ASTPrimaryExpression(this, JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimaryExpression */
    try {
/*@egen*/
    (
        <NULL>
    |   <TRUE>
    |   <FALSE>
    |   <DECIMAL_LITERAL> 
    |   <OCTAL_LITERAL>
    |   <HEX_LITERAL>
    |   <FLOATING_POINT_LITERAL> 
    |   <STRING_LITERAL> 
    |   <THIS>
    |   <REGULAR_EXPRESSION>
    |   <LPAREN> ListExpression() <RPAREN>
    |   ArrayLiteral()
    |   ObjectLiteral()
    |   FunctionExpression()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        token_source.setRegValid();
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReservedNamespace ():
{/*@bgen(jjtree) ReservedNamespace */
  ASTReservedNamespace jjtn000 = new ASTReservedNamespace(this, JJTRESERVEDNAMESPACE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReservedNamespace */
       try {
/*@egen*/
       <PUBLIC>
    |  <PROTECTED>
    |  <PRIVATE>/*@bgen(jjtree)*/
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/
}

/////////////////////////////////////////////////////
// Function Expression
/////////////////////////////////////////////////////
void  FunctionExpression ():
{/*@bgen(jjtree) FunctionExpression */
  ASTFunctionExpression jjtn000 = new ASTFunctionExpression(this, JJTFUNCTIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionExpression */
        try {
/*@egen*/
        LOOKAHEAD(2) <FUNCTION> FunctionCommon()
    |                <FUNCTION> Identifier() FunctionCommon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Object Literals
/////////////////////////////////////////////////////
void ObjectLiteral ():
{/*@bgen(jjtree) ObjectLiteral */
  ASTObjectLiteral jjtn000 = new ASTObjectLiteral(this, JJTOBJECTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectLiteral */
        try {
/*@egen*/
        <LBRACE> [FieldList()] <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/  
}        

void FieldList():
{/*@bgen(jjtree) FieldList */
  ASTFieldList jjtn000 = new ASTFieldList(this, JJTFIELDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldList */
        try {
/*@egen*/
        LiteralField() (<COMMA> LiteralField())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LiteralField ():
{/*@bgen(jjtree) LiteralField */
  ASTLiteralField jjtn000 = new ASTLiteralField(this, JJTLITERALFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LiteralField */
        try {
/*@egen*/
        FieldName() <COLON> AssignmentExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FieldName ():
{/*@bgen(jjtree) FieldName */
  ASTFieldName jjtn000 = new ASTFieldName(this, JJTFIELDNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldName */
        try {
/*@egen*/
        <STRING_LITERAL>
    |   <DECIMAL_LITERAL>
    |   SimpleQualifiedIdentifier()
    |   <LPAREN> AssignmentExpression() <RPAREN> [<QUALIFIER> Identifier()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}	

/////////////////////////////////////////////////////
// Array Literal
/////////////////////////////////////////////////////
void ArrayLiteral():
{/*@bgen(jjtree) ArrayLiteral */
  ASTArrayLiteral jjtn000 = new ASTArrayLiteral(this, JJTARRAYLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayLiteral */
        try {
/*@egen*/
        <LBRACKET> [ElementList()] <RBRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ElementList():
{/*@bgen(jjtree) ElementList */
  ASTElementList jjtn000 = new ASTElementList(this, JJTELEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElementList */
        try {
/*@egen*/
        LiteralElement() (<COMMA> LiteralElement())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LiteralElement():
{/*@bgen(jjtree) LiteralElement */
  ASTLiteralElement jjtn000 = new ASTLiteralElement(this, JJTLITERALELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LiteralElement */
        try {
/*@egen*/
        AssignmentExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Super Expression
/////////////////////////////////////////////////////
void SuperExpression ():
{/*@bgen(jjtree) SuperExpression */
  ASTSuperExpression jjtn000 = new ASTSuperExpression(this, JJTSUPEREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SuperExpression */
        try {
/*@egen*/
        <SUPER> [LOOKAHEAD(2) <LPAREN> AssignmentExpression() <RPAREN>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Postfix Expression
/////////////////////////////////////////////////////
void PostfixExpression ():
{/*@bgen(jjtree) PostfixExpression */
  ASTPostfixExpression jjtn000 = new ASTPostfixExpression(this, JJTPOSTFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PostfixExpression */
        try {
/*@egen*/
        AttributeExpression ()                            [PostfixOp()]
    |   {token_source.setRegInvalid();} 
        FullPostfixExpression () (PropertyOrArguments())* [PostfixOp()]
    |   SuperExpression()         PropertyOperator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}    

void AttributeExpression ():
{/*@bgen(jjtree) AttributeExpression */
  ASTAttributeExpression jjtn000 = new ASTAttributeExpression(this, JJTATTRIBUTEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttributeExpression */
        try {
/*@egen*/
        SimpleQualifiedIdentifier()  (PropertyOrArguments())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FullPostfixExpression ():
{/*@bgen(jjtree) FullPostfixExpression */
  ASTFullPostfixExpression jjtn000 = new ASTFullPostfixExpression(this, JJTFULLPOSTFIXEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FullPostfixExpression */
       try {
/*@egen*/
       LOOKAHEAD(<LPAREN> AssignmentExpression() <RPAREN> <QUALIFIER>) 
       ExpressionQualifiedIdentifier()
    |  PrimaryExpression() 
    |  FullNewExpression()/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/             
}

void FullNewExpression ():
{/*@bgen(jjtree) FullNewExpression */
  ASTFullNewExpression jjtn000 = new ASTFullNewExpression(this, JJTFULLNEWEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FullNewExpression */
        try {
/*@egen*/
        <NEW> FullNewSubexpression()  (LOOKAHEAD(2) PropertyOperator())* [LOOKAHEAD(2) Arguments()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionConstructor():
{/*@bgen(jjtree) FunctionConstructor */
  ASTFunctionConstructor jjtn000 = new ASTFunctionConstructor(this, JJTFUNCTIONCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionConstructor */
        try {
/*@egen*/    
        <FUNCTION_> Arguments()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FullNewSubexpression ():
{/*@bgen(jjtree) FullNewSubexpression */
  ASTFullNewSubexpression jjtn000 = new ASTFullNewSubexpression(this, JJTFULLNEWSUBEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FullNewSubexpression */
        try {
/*@egen*/
        LOOKAHEAD(<LPAREN> AssignmentExpression() <RPAREN> <QUALIFIER>) 
        ExpressionQualifiedIdentifier()        
    |   PrimaryExpression() 
    |   SimpleQualifiedIdentifier()
    |   SuperExpression() 
    |   FullNewExpression()
    |   FunctionConstructor()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void PostfixOp():
{/*@bgen(jjtree) PostfixOp */
  ASTPostfixOp jjtn000 = new ASTPostfixOp(this, JJTPOSTFIXOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PostfixOp */
        try {
/*@egen*/
        <INCR>
    |   <DECR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PropertyOrArguments ():
{/*@bgen(jjtree) PropertyOrArguments */
  ASTPropertyOrArguments jjtn000 = new ASTPropertyOrArguments(this, JJTPROPERTYORARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropertyOrArguments */
        try {
/*@egen*/
        Arguments()        
    |   PropertyOperator()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Property Operators
/////////////////////////////////////////////////////
void PropertyOperator ():
{/*@bgen(jjtree) PropertyOperator */
  ASTPropertyOperator jjtn000 = new ASTPropertyOperator(this, JJTPROPERTYOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropertyOperator */
        try {
/*@egen*/          
        <DOT>      QualifiedIdentifier()
    |   LOOKAHEAD(2) <LBRACKET> <RBRACKET>
    |   LOOKAHEAD(2) <LBRACKET> <ELIPSE> AssignmentExpression() <RBRACKET>
    |                <LBRACKET> ListExpression() [<ELIPSE> AssignmentExpression()] <RBRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Arguments ():
{/*@bgen(jjtree) Arguments */
 ASTArguments jjtn000 = new ASTArguments(this, JJTARGUMENTS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/{token_source.setRegValid();}}
{/*@bgen(jjtree) Arguments */
        try {
/*@egen*/
        LOOKAHEAD(2) <LPAREN> <RPAREN>
    |   LOOKAHEAD(2) <LPAREN> <ELIPSE> AssignmentExpression() <RPAREN>
    |                <LPAREN> ListExpression() [<ELIPSE> AssignmentExpression()] <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Unary Operators 
/////////////////////////////////////////////////////
void UnaryExpression ():
{/*@bgen(jjtree) UnaryExpression */
  ASTUnaryExpression jjtn000 = new ASTUnaryExpression(this, JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnaryExpression */
                 try {
/*@egen*/
                 PostfixExpression()
    |   <DELETE> PostfixExpression()
    |   <VOID>   UnaryExpression()
    |   <TYPEOF> UnaryExpression()
    |   <INCR>   PostfixExpression()
    |   <DECR>   PostfixExpression()
    |   <PLUS>   UnaryExpression()
    |   <MINUS>  UnaryExpression()
    |   <TILDE>  UnaryExpression()
    |   <BANG>   UnaryExpression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte000) {
                   if (jjtc000) {
                     jjtree.clearNodeScope(jjtn000);
                     jjtc000 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte000 instanceof RuntimeException) {
                     throw (RuntimeException)jjte000;
                   }
                   if (jjte000 instanceof ParseException) {
                     throw (ParseException)jjte000;
                   }
                   throw (Error)jjte000;
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                   }
                 }
/*@egen*/
}

/////////////////////////////////////////////////////
// Multiplicative Operators 
/////////////////////////////////////////////////////
void MulOp():
{/*@bgen(jjtree) MulOp */
  ASTMulOp jjtn000 = new ASTMulOp(this, JJTMULOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MulOp */
        try {
/*@egen*/
        <STAR>
    |   <SLASH>
    |   <REM>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void MultiplicativeExpression():
{/*@bgen(jjtree) MultiplicativeExpression */
  ASTMultiplicativeExpression jjtn000 = new ASTMultiplicativeExpression(this, JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiplicativeExpression */
        try {
/*@egen*/
        UnaryExpression() (MulOp() UnaryExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

/////////////////////////////////////////////////////
// Additive Operators 
/////////////////////////////////////////////////////
void AddOp():
{/*@bgen(jjtree) AddOp */
  ASTAddOp jjtn000 = new ASTAddOp(this, JJTADDOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AddOp */
        try {
/*@egen*/
        <PLUS>
    |   <MINUS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AdditiveExpression():
{/*@bgen(jjtree) AdditiveExpression */
  ASTAdditiveExpression jjtn000 = new ASTAdditiveExpression(this, JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AdditiveExpression */
        try {
/*@egen*/
        MultiplicativeExpression() (AddOp() MultiplicativeExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

/////////////////////////////////////////////////////
// Bitwise Shift Operators 
/////////////////////////////////////////////////////
void ShiftOp():
{/*@bgen(jjtree) ShiftOp */
  ASTShiftOp jjtn000 = new ASTShiftOp(this, JJTSHIFTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ShiftOp */
        try {
/*@egen*/
        <LSHIFT>
    |   <RSIGNEDSHIFT>
    |   <RUNSIGNEDSHIFT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ShiftExpression():
{/*@bgen(jjtree) ShiftExpression */
  ASTShiftExpression jjtn000 = new ASTShiftExpression(this, JJTSHIFTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ShiftExpression */
        try {
/*@egen*/
        AdditiveExpression() (ShiftOp() AdditiveExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Relational Operators 
/////////////////////////////////////////////////////
void RelOp():
{/*@bgen(jjtree) RelOp */
  ASTRelOp jjtn000 = new ASTRelOp(this, JJTRELOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelOp */
        try {
/*@egen*/
        <LT>
    |   <GT> 
    |   <LE> 
    |   <GE>
    |   <IS>
    |   <AS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RelationalExpression():
{/*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(this, JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpression */
        try {
/*@egen*/
        ShiftExpression() 
            (LOOKAHEAD(3)(RelOp() | <IN> | <INSTANCEOF> ) ShiftExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RelationalExpressionNoIN():
{/*@bgen(jjtree) RelationalExpressionNoIN */
  ASTRelationalExpressionNoIN jjtn000 = new ASTRelationalExpressionNoIN(this, JJTRELATIONALEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RelationalExpressionNoIN */
        try {
/*@egen*/
        ShiftExpression() 
            ((RelOp() | <INSTANCEOF>)  ShiftExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Equality Operators 
/////////////////////////////////////////////////////
void EqualOp():
{/*@bgen(jjtree) EqualOp */
  ASTEqualOp jjtn000 = new ASTEqualOp(this, JJTEQUALOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualOp */
        try {
/*@egen*/
        <EQ> 
    |   <NE> 
    |   <IDENTITYOPER> 
    |   <NOTIDENTITYOPER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EqualityExpression():
{/*@bgen(jjtree) EqualityExpression */
  ASTEqualityExpression jjtn000 = new ASTEqualityExpression(this, JJTEQUALITYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualityExpression */
        try {
/*@egen*/
        RelationalExpression() (EqualOp() RelationalExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EqualityExpressionNoIN():
{/*@bgen(jjtree) EqualityExpressionNoIN */
  ASTEqualityExpressionNoIN jjtn000 = new ASTEqualityExpressionNoIN(this, JJTEQUALITYEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EqualityExpressionNoIN */
        try {
/*@egen*/
        RelationalExpressionNoIN() (EqualOp() RelationalExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Binary Bitwise Operators 
/////////////////////////////////////////////////////
void BitwiseANDOp():
{/*@bgen(jjtree) BitwiseANDOp */
  ASTBitwiseANDOp jjtn000 = new ASTBitwiseANDOp(this, JJTBITWISEANDOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseANDOp */
        try {
/*@egen*/
        <BIT_AND>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseANDExpression():
{/*@bgen(jjtree) BitwiseANDExpression */
  ASTBitwiseANDExpression jjtn000 = new ASTBitwiseANDExpression(this, JJTBITWISEANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseANDExpression */
        try {
/*@egen*/
        EqualityExpression() (BitwiseANDOp() EqualityExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseANDExpressionNoIN():
{/*@bgen(jjtree) BitwiseANDExpressionNoIN */
  ASTBitwiseANDExpressionNoIN jjtn000 = new ASTBitwiseANDExpressionNoIN(this, JJTBITWISEANDEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseANDExpressionNoIN */
        try {
/*@egen*/
        EqualityExpressionNoIN() (BitwiseANDOp() EqualityExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void BitwiseXOROp():
{/*@bgen(jjtree) BitwiseXOROp */
  ASTBitwiseXOROp jjtn000 = new ASTBitwiseXOROp(this, JJTBITWISEXOROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseXOROp */
        try {
/*@egen*/
        <XOR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseXORExpression():
{/*@bgen(jjtree) BitwiseXORExpression */
  ASTBitwiseXORExpression jjtn000 = new ASTBitwiseXORExpression(this, JJTBITWISEXOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseXORExpression */
        try {
/*@egen*/
        BitwiseANDExpression() (BitwiseXOROp() BitwiseANDExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseXORExpressionNoIN():
{/*@bgen(jjtree) BitwiseXORExpressionNoIN */
  ASTBitwiseXORExpressionNoIN jjtn000 = new ASTBitwiseXORExpressionNoIN(this, JJTBITWISEXOREXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseXORExpressionNoIN */
        try {
/*@egen*/
        BitwiseANDExpressionNoIN() (BitwiseXOROp() BitwiseANDExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseOROp():
{/*@bgen(jjtree) BitwiseOROp */
  ASTBitwiseOROp jjtn000 = new ASTBitwiseOROp(this, JJTBITWISEOROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseOROp */
        try {
/*@egen*/
        <BIT_OR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseORExpression():
{/*@bgen(jjtree) BitwiseORExpression */
  ASTBitwiseORExpression jjtn000 = new ASTBitwiseORExpression(this, JJTBITWISEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseORExpression */
        try {
/*@egen*/
        BitwiseXORExpression() (BitwiseOROp() BitwiseXORExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BitwiseORExpressionNoIN():
{/*@bgen(jjtree) BitwiseORExpressionNoIN */
  ASTBitwiseORExpressionNoIN jjtn000 = new ASTBitwiseORExpressionNoIN(this, JJTBITWISEOREXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BitwiseORExpressionNoIN */
        try {
/*@egen*/
        BitwiseXORExpressionNoIN() (BitwiseOROp() BitwiseXORExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Binary Logical Operators 
/////////////////////////////////////////////////////
void LogicalANDExpression():
{/*@bgen(jjtree) LogicalANDExpression */
  ASTLogicalANDExpression jjtn000 = new ASTLogicalANDExpression(this, JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalANDExpression */
        try {
/*@egen*/
        BitwiseORExpression() (<SC_AND> BitwiseORExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalANDExpressionNoIN():
{/*@bgen(jjtree) LogicalANDExpressionNoIN */
  ASTLogicalANDExpressionNoIN jjtn000 = new ASTLogicalANDExpressionNoIN(this, JJTLOGICALANDEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalANDExpressionNoIN */
        try {
/*@egen*/
        BitwiseORExpressionNoIN() (<SC_AND> BitwiseORExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalORExpression():
{/*@bgen(jjtree) LogicalORExpression */
  ASTLogicalORExpression jjtn000 = new ASTLogicalORExpression(this, JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalORExpression */
        try {
/*@egen*/
        LogicalANDExpression() (<SC_OR> LogicalANDExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicalORExpressionNoIN():
{/*@bgen(jjtree) LogicalORExpressionNoIN */
  ASTLogicalORExpressionNoIN jjtn000 = new ASTLogicalORExpressionNoIN(this, JJTLOGICALOREXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalORExpressionNoIN */
        try {
/*@egen*/
        LogicalANDExpressionNoIN() (<SC_OR> LogicalANDExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Conditional Operators 
/////////////////////////////////////////////////////
void ConditionalExpression():
{/*@bgen(jjtree) ConditionalExpression */
  ASTConditionalExpression jjtn000 = new ASTConditionalExpression(this, JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
        try {
/*@egen*/
        LogicalORExpression() [<HOOK>  AssignmentExpression() 
                               <COLON> AssignmentExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConditionalExpressionNoIN():
{/*@bgen(jjtree) ConditionalExpressionNoIN */
  ASTConditionalExpressionNoIN jjtn000 = new ASTConditionalExpressionNoIN(this, JJTCONDITIONALEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpressionNoIN */
        try {
/*@egen*/
        LogicalORExpressionNoIN()  [<HOOK>  AssignmentExpressionNoIN() 
                                    <COLON> AssignmentExpressionNoIN()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NonAssignmentExpression():
{/*@bgen(jjtree) NonAssignmentExpression */
  ASTNonAssignmentExpression jjtn000 = new ASTNonAssignmentExpression(this, JJTNONASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NonAssignmentExpression */
        try {
/*@egen*/
        LogicalORExpression() [<HOOK>  NonAssignmentExpression() 
                               <COLON> NonAssignmentExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NonAssignmentExpressionNoIN():
{/*@bgen(jjtree) NonAssignmentExpressionNoIN */
  ASTNonAssignmentExpressionNoIN jjtn000 = new ASTNonAssignmentExpressionNoIN(this, JJTNONASSIGNMENTEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NonAssignmentExpressionNoIN */
        try {
/*@egen*/
        LogicalORExpressionNoIN() [<HOOK>  NonAssignmentExpressionNoIN() 
                                   <COLON> NonAssignmentExpressionNoIN()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Assignment Operators 
/////////////////////////////////////////////////////
void AssignementOperator():
{/*@bgen(jjtree) AssignementOperator */
  ASTAssignementOperator jjtn000 = new ASTAssignementOperator(this, JJTASSIGNEMENTOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignementOperator */
        try {
/*@egen*/
        <ASSIGN>
    |   <STARASSIGN>
    |   <SLASHASSIGN> 
    |   <REMASSIGN> 
    |   <PLUSASSIGN>
    |   <MINUSASSIGN> 
    |   <LSHIFTASSIGN> 
    |   <RSIGNEDSHIFTASSIGN>
    |   <RUNSIGNEDSHIFTASSIGN>
    |   <ANDASSIGN> 
    |   <XORASSIGN> 
    |   <ORASSIGN>
    |   <SC_ANDASSIGN>
    |   <SC_XORASSIGN>
    |   <SC_ORASSIGN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
 
}

void AssignmentExpression():
{/*@bgen(jjtree) AssignmentExpression */
  ASTAssignmentExpression jjtn000 = new ASTAssignmentExpression(this, JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
        try {
/*@egen*/
        ConditionalExpression() [LOOKAHEAD(2) AssignementOperator() AssignmentExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AssignmentExpressionNoIN():
{/*@bgen(jjtree) AssignmentExpressionNoIN */
  ASTAssignmentExpressionNoIN jjtn000 = new ASTAssignmentExpressionNoIN(this, JJTASSIGNMENTEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpressionNoIN */
        try {
/*@egen*/
        ConditionalExpressionNoIN() [LOOKAHEAD(2) AssignementOperator() AssignmentExpressionNoIN()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Comma Expressions
/////////////////////////////////////////////////////
void ListExpression ():
{/*@bgen(jjtree) ListExpression */
  ASTListExpression jjtn000 = new ASTListExpression(this, JJTLISTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListExpression */
        try {
/*@egen*/
        AssignmentExpression() (<COMMA> AssignmentExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}   

void ListExpressionNoIN ():
{/*@bgen(jjtree) ListExpressionNoIN */
  ASTListExpressionNoIN jjtn000 = new ASTListExpressionNoIN(this, JJTLISTEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListExpressionNoIN */
        try {
/*@egen*/
        AssignmentExpressionNoIN() (<COMMA> AssignmentExpressionNoIN())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}   

/////////////////////////////////////////////////////
// Type Expressions
/////////////////////////////////////////////////////
void TypeExpression ():
{/*@bgen(jjtree) TypeExpression */
  ASTTypeExpression jjtn000 = new ASTTypeExpression(this, JJTTYPEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeExpression */
        try {
/*@egen*/
        NonAssignmentExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeExpressionNoIN ():
{/*@bgen(jjtree) TypeExpressionNoIN */
  ASTTypeExpressionNoIN jjtn000 = new ASTTypeExpressionNoIN(this, JJTTYPEEXPRESSIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeExpressionNoIN */
        try {
/*@egen*/
        NonAssignmentExpressionNoIN()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypeExpressionList ():
{/*@bgen(jjtree) TypeExpressionList */
  ASTTypeExpressionList jjtn000 = new ASTTypeExpressionList(this, JJTTYPEEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeExpressionList */
        try {
/*@egen*/
        NonAssignmentExpression() (<COMMA> NonAssignmentExpression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
/////////////////////////////////////////////////////
// Staements (abbrev, noShortIf, full) 
/////////////////////////////////////////////////////
void Statement ():
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
        try {
/*@egen*/
        LOOKAHEAD(3) ExpressionStatement() Sc()
    |                SuperStatement() Sc()
    |                Block()
    |                LabeledStatement()
    |                IfStatement()
    |                SwitchStatement()
    |                DoStatement() Sc()
    |                WhileStatement()
    |                ForStatement()
    |                WithStatement()
    |                ContinueStatement() Sc()
    |                BreakStatement() Sc()
    |                ReturnStatement() Sc()
    |                ThrowStatement() Sc()
    |                TryStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substatement ():
{/*@bgen(jjtree) Substatement */
  ASTSubstatement jjtn000 = new ASTSubstatement(this, JJTSUBSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Substatement */
                     try {
/*@egen*/
                     EmptyStatement()
    |   LOOKAHEAD(2) Statement()
    |                SimpleVariableDefinition() Sc()
    |                Attributes()               <LBRACE> Substatements() <RBRACE>/*@bgen(jjtree)*/
                     } catch (Throwable jjte000) {
                       if (jjtc000) {
                         jjtree.clearNodeScope(jjtn000);
                         jjtc000 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte000 instanceof RuntimeException) {
                         throw (RuntimeException)jjte000;
                       }
                       if (jjte000 instanceof ParseException) {
                         throw (ParseException)jjte000;
                       }
                       throw (Error)jjte000;
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/
}

void Substatements ():
{/*@bgen(jjtree) Substatements */
  ASTSubstatements jjtn000 = new ASTSubstatements(this, JJTSUBSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Substatements */
        try {
/*@egen*/
        (Substatement())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

JAVACODE
  void Sc() {/*@bgen(jjtree) Sc */
 ASTSc jjtn000 = new ASTSc(this, JJTSC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/
    Token tok = getToken(1);
    if (tok.kind == SEMICOLON) {
       tok = getNextToken();
    } else if (tok.specialToken != null) {
       if (!EolCommentSkipWs(tok.specialToken) && (tok.kind != EOF)) {
          throw generateParseException();
       }
    } else if ((tok.kind != EOF) && (tok.kind!=RBRACE)) {
         throw generateParseException();
    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
  }
 
JAVACODE
  boolean EolCommentSkipWs(Token t) {/*@bgen(jjtree) EolCommentSkipWs */
 ASTEolCommentSkipWs jjtn000 = new ASTEolCommentSkipWs(this, JJTEOLCOMMENTSKIPWS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/
    boolean retVal = false;
    Token specialToken = t;
    while(specialToken != null) {
      if(specialToken.kind == WS) {
        specialToken = specialToken.specialToken;
        continue;
      }
      else if(specialToken.kind == EOL  ||
              specialToken.kind == SINGLE_LINE_COMMENT) {
        retVal = true;
        break;
      }
      else {
        break;
      }
    }
    return retVal;/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
  }
 
/////////////////////////////////////////////////////
// Empty Statement 
/////////////////////////////////////////////////////
void EmptyStatement():
{/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(this, JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyStatement */
        try {
/*@egen*/
        <SEMICOLON>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Expresion Statement 
/////////////////////////////////////////////////////
void ExpressionStatement():
{/*@bgen(jjtree) ExpressionStatement */
  ASTExpressionStatement jjtn000 = new ASTExpressionStatement(this, JJTEXPRESSIONSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionStatement */
        try {
/*@egen*/
        ListExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/////////////////////////////////////////////////////
// Super Statement 
/////////////////////////////////////////////////////
void SuperStatement ():
{/*@bgen(jjtree) SuperStatement */
  ASTSuperStatement jjtn000 = new ASTSuperStatement(this, JJTSUPERSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SuperStatement */
        try {
/*@egen*/
        <SUPER> Arguments()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Block Statement 
/////////////////////////////////////////////////////
void Block ():
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
        try {
/*@egen*/   
        <LBRACE> [Directives()] <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Labeled Statement (maps to literal field)
/////////////////////////////////////////////////////
void LabeledStatement ():
{/*@bgen(jjtree) LabeledStatement */
  ASTLabeledStatement jjtn000 = new ASTLabeledStatement(this, JJTLABELEDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabeledStatement */
        try {
/*@egen*/
        Identifier() <COLON> Substatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// If Statement 
/////////////////////////////////////////////////////
void IfStatement():
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
        try {
/*@egen*/
        <IF> <LPAREN> ListExpression() <RPAREN> 
            Substatement() 
            [LOOKAHEAD(1) <ELSE> Substatement()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Switch Statement 
/////////////////////////////////////////////////////
void SwitchStatement ():
{/*@bgen(jjtree) SwitchStatement */
  ASTSwitchStatement jjtn000 = new ASTSwitchStatement(this, JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchStatement */
        try {
/*@egen*/
        <SWITCH> <LPAREN> ListExpression() <RPAREN>
                 <LBRACE> [CaseElements()] <RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseElements ():
{/*@bgen(jjtree) CaseElements */
  ASTCaseElements jjtn000 = new ASTCaseElements(this, JJTCASEELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseElements */
        try {
/*@egen*/
        CaseLabel() (CaseElement())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseElement ():
{/*@bgen(jjtree) CaseElement */
  ASTCaseElement jjtn000 = new ASTCaseElement(this, JJTCASEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseElement */
        try {
/*@egen*/
        Directive()
    |   CaseLabel()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseLabel ():
{/*@bgen(jjtree) CaseLabel */
  ASTCaseLabel jjtn000 = new ASTCaseLabel(this, JJTCASELABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseLabel */
        try {
/*@egen*/
        <CASE> ListExpression() <COLON>
    |   <_DEFAULT> <COLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Do-While Statement 
/////////////////////////////////////////////////////
void DoStatement(): 
{/*@bgen(jjtree) DoStatement */
  ASTDoStatement jjtn000 = new ASTDoStatement(this, JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoStatement */
        try {
/*@egen*/
        <DO> Substatement() <WHILE> <LPAREN> ListExpression() <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// While Statement
/////////////////////////////////////////////////////
void WhileStatement ():
{/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(this, JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
        try {
/*@egen*/
        <WHILE> <LPAREN> ListExpression() <RPAREN>
           Substatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// For Statements 
/////////////////////////////////////////////////////
void ForStatement ():
{/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(this, JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
         try {
/*@egen*/
         LOOKAHEAD(<FOR> <LPAREN> ForInBinding() <IN>)
                   <FOR> <LPAREN> ForInBinding() <IN> ListExpression() <RPAREN>
                      Substatement()
    |              <FOR> <LPAREN> [ForInitializer()] <SEMICOLON> 
                       [ListExpression()] <SEMICOLON> 
                       [ListExpression()] <RPAREN> 
                      Substatement()/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void ForInitializer ():
{/*@bgen(jjtree) ForInitializer */
  ASTForInitializer jjtn000 = new ASTForInitializer(this, JJTFORINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForInitializer */
        try {
/*@egen*/
        LOOKAHEAD(3) ListExpressionNoIN()
    |                VariableDefinitionNoIN()
    |                Attributes()             VariableDefinitionNoIN()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForInBinding ():
{/*@bgen(jjtree) ForInBinding */
  ASTForInBinding jjtn000 = new ASTForInBinding(this, JJTFORINBINDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForInBinding */
        try {
/*@egen*/
        LOOKAHEAD(3) PostfixExpression()
    |                VariableDefinitionKind() VariableBindingNoIN()
    |                Attributes()             VariableDefinitionKind() VariableBindingNoIN()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// With Statement 
/////////////////////////////////////////////////////
void WithStatement():
{/*@bgen(jjtree) WithStatement */
  ASTWithStatement jjtn000 = new ASTWithStatement(this, JJTWITHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WithStatement */
        try {
/*@egen*/
        <WITH> <LPAREN> ExpressionStatement() <RPAREN>
            Substatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Continue and Break Statement
/////////////////////////////////////////////////////
void ContinueStatement():
{/*@bgen(jjtree) ContinueStatement */
  ASTContinueStatement jjtn000 = new ASTContinueStatement(this, JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ContinueStatement */
        try {
/*@egen*/
        <CONTINUE> [Identifier()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BreakStatement():
{/*@bgen(jjtree) BreakStatement */
  ASTBreakStatement jjtn000 = new ASTBreakStatement(this, JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BreakStatement */
        try {
/*@egen*/
        <BREAK> [Identifier()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
 

/////////////////////////////////////////////////////
// Return Statement
/////////////////////////////////////////////////////
void ReturnStatement():
{/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(this, JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
        try {
/*@egen*/
        <RETURN> [ListExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Throw Statement
/////////////////////////////////////////////////////
void ThrowStatement():
{/*@bgen(jjtree) ThrowStatement */
  ASTThrowStatement jjtn000 = new ASTThrowStatement(this, JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ThrowStatement */
        try {
/*@egen*/
        <THROW> ListExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Try Statement
/////////////////////////////////////////////////////
void TryStatement():
{/*@bgen(jjtree) TryStatement */
  ASTTryStatement jjtn000 = new ASTTryStatement(this, JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TryStatement */
        try {
/*@egen*/
        <TRY> Block()
        (<CATCH> <LPAREN> Identifier() <RPAREN> Block())*
        [<FINALLY> Block()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 
 
/////////////////////////////////////////////////////
// Directives 
/////////////////////////////////////////////////////
void Directives ():
{/*@bgen(jjtree) Directives */
  ASTDirectives jjtn000 = new ASTDirectives(this, JJTDIRECTIVES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Directives */
        try {
/*@egen*/
        (Directive())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Directive ():
{/*@bgen(jjtree) Directive */
  ASTDirective jjtn000 = new ASTDirective(this, JJTDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Directive */
                      try {
/*@egen*/
                      EmptyStatement()
     |   LOOKAHEAD(3) Statement()
     |   LOOKAHEAD(2) AnnotatableDirective()
     |   LOOKAHEAD(2) Attributes()            <LBRACE> Directives() <RBRACE>
     |   LOOKAHEAD(2) Attributes()            AnnotatableDirective() 
     |                IncludeDirective()      Sc()
     |                Pragma()                Sc()/*@bgen(jjtree)*/
                      } catch (Throwable jjte000) {
                        if (jjtc000) {
                          jjtree.clearNodeScope(jjtn000);
                          jjtc000 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte000 instanceof RuntimeException) {
                          throw (RuntimeException)jjte000;
                        }
                        if (jjte000 instanceof ParseException) {
                          throw (ParseException)jjte000;
                        }
                        throw (Error)jjte000;
                      } finally {
                        if (jjtc000) {
                          jjtree.closeNodeScope(jjtn000, true);
                        }
                      }
/*@egen*/
}

void AnnotatableDirective ():
{/*@bgen(jjtree) AnnotatableDirective */
  ASTAnnotatableDirective jjtn000 = new ASTAnnotatableDirective(this, JJTANNOTATABLEDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnnotatableDirective */
         try {
/*@egen*/
         VariableDefinition() Sc()
     |   FunctionDefinition()
     |   ClassDefinition()
     |   InterfaceDefinition()
     |   NamespaceDefinition() Sc()
     |   ImportDirective() Sc()
     |   ExportDefinition() Sc()
     |   UseDirective() Sc()/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}
/////////////////////////////////////////////////////
// Attributes
/////////////////////////////////////////////////////
void Attributes ():
{/*@bgen(jjtree) Attributes */
  ASTAttributes jjtn000 = new ASTAttributes(this, JJTATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Attributes */
        try {
/*@egen*/
        (Attribute ())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Attribute ():
{/*@bgen(jjtree) Attribute */
  ASTAttribute jjtn000 = new ASTAttribute(this, JJTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Attribute */
                     try {
/*@egen*/
                     AttributeExpression()
    |                <TRUE>
    |                <FALSE>/*@bgen(jjtree)*/
                     } catch (Throwable jjte000) {
                       if (jjtc000) {
                         jjtree.clearNodeScope(jjtn000);
                         jjtc000 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte000 instanceof RuntimeException) {
                         throw (RuntimeException)jjte000;
                       }
                       if (jjte000 instanceof ParseException) {
                         throw (ParseException)jjte000;
                       }
                       throw (Error)jjte000;
                     } finally {
                       if (jjtc000) {
                         jjtree.closeNodeScope(jjtn000, true);
                       }
                     }
/*@egen*/
}

/////////////////////////////////////////////////////
// Use Directive
/////////////////////////////////////////////////////
void UseDirective ():
{/*@bgen(jjtree) UseDirective */
  ASTUseDirective jjtn000 = new ASTUseDirective(this, JJTUSEDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UseDirective */
        try {
/*@egen*/ 
        <USE> <NAMESPACE> <LPAREN> ListExpression() <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Import Directive
/////////////////////////////////////////////////////
void ImportDirective ():
{/*@bgen(jjtree) ImportDirective */
  ASTImportDirective jjtn000 = new ASTImportDirective(this, JJTIMPORTDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImportDirective */
        try {
/*@egen*/
        LOOKAHEAD(3) <IMPORT> PackageName()
    |                <IMPORT> Identifier() <ASSIGN> PackageName()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Include Directive
/////////////////////////////////////////////////////
void IncludeDirective (): 
{/*@bgen(jjtree) IncludeDirective */
  ASTIncludeDirective jjtn000 = new ASTIncludeDirective(this, JJTINCLUDEDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IncludeDirective */
        try {
/*@egen*/
        <INCLUDE> <STRING_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Pragma
/////////////////////////////////////////////////////
void Pragma ():
{/*@bgen(jjtree) Pragma */
  ASTPragma jjtn000 = new ASTPragma(this, JJTPRAGMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pragma */
        try {
/*@egen*/
        <USE> PragmaItems()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PragmaItems ():
{/*@bgen(jjtree) PragmaItems */
  ASTPragmaItems jjtn000 = new ASTPragmaItems(this, JJTPRAGMAITEMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PragmaItems */
        try {
/*@egen*/
        PragmaItem() (<COMMA> PragmaItem())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PragmaItem ():
{/*@bgen(jjtree) PragmaItem */
  ASTPragmaItem jjtn000 = new ASTPragmaItem(this, JJTPRAGMAITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PragmaItem */
        try {
/*@egen*/
        PragmaExpr() [<HOOK>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void PragmaExpr ():
{/*@bgen(jjtree) PragmaExpr */
  ASTPragmaExpr jjtn000 = new ASTPragmaExpr(this, JJTPRAGMAEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PragmaExpr */
        try {
/*@egen*/
        Identifier() [<LPAREN> PragmaArgument() <RPAREN>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PragmaArgument ():
{/*@bgen(jjtree) PragmaArgument */
  ASTPragmaArgument jjtn000 = new ASTPragmaArgument(this, JJTPRAGMAARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PragmaArgument */
        try {
/*@egen*/
        <TRUE>
    |   <FALSE>
    |   <DECIMAL_LITERAL> 
    |   <OCTAL_LITERAL>
    |   <HEX_LITERAL>
    |   <FLOATING_POINT_LITERAL> 
    |   <STRING_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/////////////////////////////////////////////////////
// Definitions 
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
// Export Definition 
/////////////////////////////////////////////////////
void ExportDefinition ():
{/*@bgen(jjtree) ExportDefinition */
  ASTExportDefinition jjtn000 = new ASTExportDefinition(this, JJTEXPORTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExportDefinition */
        try {
/*@egen*/
        <EXPORT> ExportBindingList ()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExportBindingList ():
{/*@bgen(jjtree) ExportBindingList */
  ASTExportBindingList jjtn000 = new ASTExportBindingList(this, JJTEXPORTBINDINGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExportBindingList */
        try {
/*@egen*/
        ExportBinding() (<COMMA> ExportBinding())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExportBinding ():
{/*@bgen(jjtree) ExportBinding */
  ASTExportBinding jjtn000 = new ASTExportBinding(this, JJTEXPORTBINDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExportBinding */
        try {
/*@egen*/
        LOOKAHEAD(2) FunctionName ()
    |                FunctionName () <ASSIGN> FunctionName ()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Variable Definition (in, NoIN)
/////////////////////////////////////////////////////
void VariableDefinition ():
{/*@bgen(jjtree) VariableDefinition */
  ASTVariableDefinition jjtn000 = new ASTVariableDefinition(this, JJTVARIABLEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDefinition */
        try {
/*@egen*/
        VariableDefinitionKind() VariableBindingList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableDefinitionNoIN ():
{/*@bgen(jjtree) VariableDefinitionNoIN */
  ASTVariableDefinitionNoIN jjtn000 = new ASTVariableDefinitionNoIN(this, JJTVARIABLEDEFINITIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDefinitionNoIN */
        try {
/*@egen*/
        VariableDefinitionKind() VariableBindingListNoIN()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void VariableDefinitionKind ():
{/*@bgen(jjtree) VariableDefinitionKind */
  ASTVariableDefinitionKind jjtn000 = new ASTVariableDefinitionKind(this, JJTVARIABLEDEFINITIONKIND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDefinitionKind */
        try {
/*@egen*/
        <VAR>
    |   <CONST>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableBindingList ():
{/*@bgen(jjtree) VariableBindingList */
  ASTVariableBindingList jjtn000 = new ASTVariableBindingList(this, JJTVARIABLEBINDINGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableBindingList */
   try {
/*@egen*/
   VariableBinding() (<COMMA> VariableBinding ())*/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void VariableBindingListNoIN ():
{/*@bgen(jjtree) VariableBindingListNoIN */
  ASTVariableBindingListNoIN jjtn000 = new ASTVariableBindingListNoIN(this, JJTVARIABLEBINDINGLISTNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableBindingListNoIN */
   try {
/*@egen*/
   VariableBindingNoIN() (<COMMA> VariableBindingNoIN())*/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void VariableBinding ():
{/*@bgen(jjtree) VariableBinding */
  ASTVariableBinding jjtn000 = new ASTVariableBinding(this, JJTVARIABLEBINDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableBinding */
        try {
/*@egen*/
        TypedIdentifier() [VariableInitialisation()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableBindingNoIN ():
{/*@bgen(jjtree) VariableBindingNoIN */
  ASTVariableBindingNoIN jjtn000 = new ASTVariableBindingNoIN(this, JJTVARIABLEBINDINGNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableBindingNoIN */
        try {
/*@egen*/
        TypedIdentifierNoIN() [VariableInitialisationNoIN()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void VariableInitialisation ():
{/*@bgen(jjtree) VariableInitialisation */
  ASTVariableInitialisation jjtn000 = new ASTVariableInitialisation(this, JJTVARIABLEINITIALISATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableInitialisation */
       try {
/*@egen*/
       <ASSIGN>  VariableInitializer ()/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/
}

void VariableInitialisationNoIN ():
{/*@bgen(jjtree) VariableInitialisationNoIN */
  ASTVariableInitialisationNoIN jjtn000 = new ASTVariableInitialisationNoIN(this, JJTVARIABLEINITIALISATIONNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableInitialisationNoIN */
       try {
/*@egen*/
       <ASSIGN>  VariableInitializerNoIN ()/*@bgen(jjtree)*/
       } catch (Throwable jjte000) {
         if (jjtc000) {
           jjtree.clearNodeScope(jjtn000);
           jjtc000 = false;
         } else {
           jjtree.popNode();
         }
         if (jjte000 instanceof RuntimeException) {
           throw (RuntimeException)jjte000;
         }
         if (jjte000 instanceof ParseException) {
           throw (ParseException)jjte000;
         }
         throw (Error)jjte000;
       } finally {
         if (jjtc000) {
           jjtree.closeNodeScope(jjtn000, true);
         }
       }
/*@egen*/
}

void VariableInitializer ():
{/*@bgen(jjtree) VariableInitializer */
  ASTVariableInitializer jjtn000 = new ASTVariableInitializer(this, JJTVARIABLEINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableInitializer */
        try {
/*@egen*/
        LOOKAHEAD(3) AssignmentExpression ()
    |                Attributes ()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableInitializerNoIN ():
{/*@bgen(jjtree) VariableInitializerNoIN */
  ASTVariableInitializerNoIN jjtn000 = new ASTVariableInitializerNoIN(this, JJTVARIABLEINITIALIZERNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableInitializerNoIN */
        try {
/*@egen*/
        LOOKAHEAD(3) AssignmentExpressionNoIN ()
    |                Attributes ()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void TypedIdentifier ():
{/*@bgen(jjtree) TypedIdentifier */
  ASTTypedIdentifier jjtn000 = new ASTTypedIdentifier(this, JJTTYPEDIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypedIdentifier */
        try {
/*@egen*/
        Identifier () [<COLON> TypeExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void TypedIdentifierNoIN ():
{/*@bgen(jjtree) TypedIdentifierNoIN */
  ASTTypedIdentifierNoIN jjtn000 = new ASTTypedIdentifierNoIN(this, JJTTYPEDIDENTIFIERNOIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypedIdentifierNoIN */
        try {
/*@egen*/
        Identifier () [<COLON> TypeExpressionNoIN()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Simple Variable Definition 
/////////////////////////////////////////////////////
void SimpleVariableDefinition ():
{/*@bgen(jjtree) SimpleVariableDefinition */
  ASTSimpleVariableDefinition jjtn000 = new ASTSimpleVariableDefinition(this, JJTSIMPLEVARIABLEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleVariableDefinition */
        try {
/*@egen*/
        <VAR> UntypedVariableBindingList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UntypedVariableBindingList ():
{/*@bgen(jjtree) UntypedVariableBindingList */
  ASTUntypedVariableBindingList jjtn000 = new ASTUntypedVariableBindingList(this, JJTUNTYPEDVARIABLEBINDINGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UntypedVariableBindingList */
        try {
/*@egen*/
        UntypedVariableBinding() (<COMMA> UntypedVariableBinding())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UntypedVariableBinding ():
{/*@bgen(jjtree) UntypedVariableBinding */
  ASTUntypedVariableBinding jjtn000 = new ASTUntypedVariableBinding(this, JJTUNTYPEDVARIABLEBINDING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UntypedVariableBinding */
        try {
/*@egen*/
        Identifier() VariableInitialisation()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Function Definition
/////////////////////////////////////////////////////
void FunctionDefinition ():
{/*@bgen(jjtree) FunctionDefinition */
  ASTFunctionDefinition jjtn000 = new ASTFunctionDefinition(this, JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionDefinition */
        try {
/*@egen*/
        <FUNCTION> FunctionName() FunctionCommon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionName ():
{/*@bgen(jjtree) FunctionName */
  ASTFunctionName jjtn000 = new ASTFunctionName(this, JJTFUNCTIONNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionName */
        try {
/*@egen*/
        // no line break after get
        LOOKAHEAD(2) <GET> Identifier()
        // no line break after get
    |   LOOKAHEAD(2) <SET> Identifier()
    |                 Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionCommon ():
{/*@bgen(jjtree) FunctionCommon */
  ASTFunctionCommon jjtn000 = new ASTFunctionCommon(this, JJTFUNCTIONCOMMON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionCommon */
        try {
/*@egen*/
        <LPAREN> [Parameters()] <RPAREN> [Result()] Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Parameters ():
{/*@bgen(jjtree) Parameters */
  ASTParameters jjtn000 = new ASTParameters(this, JJTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameters */
        try {
/*@egen*/
        RestParameters()
    |   ParameterInit() (<COMMA> ParameterInit())* [RestParameters()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Parameter ():
{/*@bgen(jjtree) Parameter */
  ASTParameter jjtn000 = new ASTParameter(this, JJTPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameter */
        try {
/*@egen*/
        [<CONST>] TypedIdentifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ParameterInit ():
{/*@bgen(jjtree) ParameterInit */
  ASTParameterInit jjtn000 = new ASTParameterInit(this, JJTPARAMETERINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterInit */
        try {
/*@egen*/
        Parameter() [<ASSIGN> AssignmentExpression()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RestParameters ():
{/*@bgen(jjtree) RestParameters */
  ASTRestParameters jjtn000 = new ASTRestParameters(this, JJTRESTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RestParameters */
        try {
/*@egen*/
        <ELIPSE> [<CONST> Identifier()]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Result ():
{/*@bgen(jjtree) Result */
  ASTResult jjtn000 = new ASTResult(this, JJTRESULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Result */
        try {
/*@egen*/
        <COLON> TypeExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Class Definition
/////////////////////////////////////////////////////
void ClassDefinition ():
{/*@bgen(jjtree) ClassDefinition */
  ASTClassDefinition jjtn000 = new ASTClassDefinition(this, JJTCLASSDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDefinition */
        try {
/*@egen*/
        <CLASS> Identifier() [Inheritance()] Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void InterfaceDefinition ():
{/*@bgen(jjtree) InterfaceDefinition */
  ASTInterfaceDefinition jjtn000 = new ASTInterfaceDefinition(this, JJTINTERFACEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InterfaceDefinition */
        try {
/*@egen*/
        LOOKAHEAD(3) <INTERFACE> Identifier() Sc()
    |                <INTERFACE> Identifier() 
                                 [<EXTENDS> TypeExpressionList()] Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Inheritance ():
{/*@bgen(jjtree) Inheritance */
  ASTInheritance jjtn000 = new ASTInheritance(this, JJTINHERITANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Inheritance */
        try {
/*@egen*/ 
        <EXTENDS> TypeExpression() [<IMPLEMENTS> TypeExpressionList()]
    |   <IMPLEMENTS> TypeExpressionList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Namespace Definition 
/////////////////////////////////////////////////////
void NamespaceDefinition ():
{/*@bgen(jjtree) NamespaceDefinition */
  ASTNamespaceDefinition jjtn000 = new ASTNamespaceDefinition(this, JJTNAMESPACEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NamespaceDefinition */
        try {
/*@egen*/
        <NAMESPACE> Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/////////////////////////////////////////////////////
// Package Definition 
/////////////////////////////////////////////////////
void PackageDefinition ():
{/*@bgen(jjtree) PackageDefinition */
  ASTPackageDefinition jjtn000 = new ASTPackageDefinition(this, JJTPACKAGEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PackageDefinition */
        try {
/*@egen*/
        <PACKAGE> [PackageName()] Block()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PackageName ():
{/*@bgen(jjtree) PackageName */
  ASTPackageName jjtn000 = new ASTPackageName(this, JJTPACKAGENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PackageName */
        try {
/*@egen*/
        <STRING_LITERAL>
    |   PackageIdentifiers()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PackageIdentifiers ():
{/*@bgen(jjtree) PackageIdentifiers */
  ASTPackageIdentifiers jjtn000 = new ASTPackageIdentifiers(this, JJTPACKAGEIDENTIFIERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PackageIdentifiers */
        try {
/*@egen*/
        Identifier() (<DOT> Identifier())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
